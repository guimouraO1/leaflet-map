L.TimeDimension.Layer.TileLayer = L.TimeDimension.Layer.extend({}),

L.timeDimension.layer.tileLayer = function(e, i) {
    return new L.TimeDimension.Layer.TileLayer(e,i)
},
L.TimeDimension.Layer.TileLayer.Goes = L.TimeDimension.Layer.TileLayer.extend({
    initialize: function(e, i) {
        L.TimeDimension.Layer.TileLayer.prototype.initialize.call(this, e, i),
        this._layers = {},
        this._defaultTime = 0,
        this._availableTimes = [],
        this._timeCacheBackward = this.options.cacheBackward || this.options.cache || 0,
        this._timeCacheForward = this.options.cacheForward || this.options.cache || 0,
        this._baseLayer.on("load", function() {
            this._baseLayer.setLoaded(!0),
            this.fire("timeload", {
                time: this._defaultTime
            })
        }
        .bind(this))
    },
    eachLayer: function(e, i) {
        for (var t in this._layers)
            this._layers.hasOwnProperty(t) && e.call(i, this._layers[t]);
        return L.TimeDimension.Layer.TileLayer.prototype.eachLayer.call(this, e, i)
    },
    _onNewTimeLoading: function(e) {
        var i = this._getLayerForTime(e.time);
        this._map.hasLayer(i) || this._map.addLayer(i)
    },
    isReady: function(e) {
        var i = this._getLayerForTime(e)
          , t = this._map.getZoom();
        return !!(i.options.minZoom && t < i.options.minZoom) || (!!(i.options.maxZoom && t > i.options.maxZoom) || i.isLoaded())
    },
    _update: function() {
        if (this._map) {
            var e = this._timeDimension.getCurrentTime()
              , i = this._getLayerForTime(e);
            null == this._currentLayer && (this._currentLayer = i),
            this._map.hasLayer(i) ? this._showLayer(i, e) : this._map.addLayer(i)
        }
    },
    setOpacity: function(e) {
        for (var i in L.TimeDimension.Layer.TileLayer.prototype.setOpacity.apply(this, arguments),
        this._layers)
            this._layers.hasOwnProperty(i) && this._layers[i].setOpacity && this._layers[i].setOpacity(e)
    },
    setZIndex: function(e) {
        for (var i in L.TimeDimension.Layer.TileLayer.prototype.setZIndex.apply(this, arguments),
        this._layers)
            this._layers.hasOwnProperty(i) && this._layers[i].setZIndex && this._layers[i].setZIndex(e)
    },
    _unvalidateCache: function() {
        var e = this._timeDimension.getCurrentTime();
        for (var i in this._layers)
            e != i && this._layers.hasOwnProperty(i) && (this._layers[i].setLoaded(!1),
            this._layers[i].redraw())
    },
    _evictCachedTimes: function(e, i) {
        var t, r = this._getLoadedTimes(), s = String(this._currentTime), a = r.indexOf(s), n = [];
        i > -1 && ((t = a - i) > 0 && (n = r.splice(0, t),
        this._removeLayers(n)));
        e > -1 && (a = r.indexOf(s),
        (t = r.length - a - e - 1) > 0 && (n = r.splice(a + e + 1, t),
        this._removeLayers(n)))
    },
    _showLayer: function(e, i) {
        e.isOk && (this._currentLayer && this._currentLayer !== e && this._currentLayer.hide(),
        e.show(),
        this._currentLayer && this._currentLayer === e || (this._currentLayer = e,
        this._currentTime = i,
        this._evictCachedTimes(this._timeCacheForward, this._timeCacheBackward)))
    },
    _getLayerForTime: function(e) {
        if (0 == e || e == this._defaultTime || null == e)
            return this._baseLayer;
        if (this._layers.hasOwnProperty(e))
            return this._layers[e];
        var i = this._getNearestTime(e);
        if (this._layers.hasOwnProperty(i))
            return this._layers[i];
        var t = this._createLayerForTime(i);
        return t.isOk = !0,
        t.firstShow = !0,
        this._layers[e] = t,
        t.on("load", function(e, i) {
            e.setLoaded(!0),
            this._layers[i] || (this._layers[i] = e),
            this._timeDimension && i == this._timeDimension.getCurrentTime() && !this._timeDimension.isLoading() && this._showLayer(e, i),
            this.fire("timeload", {
                time: i
            })
        }
        .bind(this, t, e)),
        t.on("tileload", function(e, i) {
            !1 !== e.firstShow && this._timeDimension && i == this._timeDimension.getCurrentTime() && !this._timeDimension.isLoading() && (this._showLayer(e, i),
            e.firstShow = !1)
        }
        .bind(this, t, e)),
        t.on("tileerror", (function(e, i) {
            t.isOk = !1
        }
        )),
        t.onAdd = function(e) {
            Object.getPrototypeOf(this).onAdd.call(this, e),
            this.hide()
        }
        .bind(t),
        t
    },
    _createURLForTime: function(e) {
        var i = this._baseLayer.getURL()
          , t = new Date(e);
        t.setUTCHours(0, 0, 0, 0);
        var r = t.toISOString().substring(0, 10).replace(/-/g, "");
        i = i.replace("{d}", r);
        var s = new Date(e).getUTCHours();
        s = (s = "00" + s).substring(s.length - 2, s.length),
        i = i.replace("{h}", s);
        var a = new Date(e).getUTCMinutes();
        return a = (a = "00" + a).substring(a.length - 2, a.length),
        i = i.replace("{m}", a)
    },
    _createLayerForTime: function(e) {
        this._baseLayer.options;
        var i = this._createURLForTime(e);
        return new this._baseLayer.constructor(i,this._baseLayer.options)
    },
    _getLoadedTimes: function() {
        var e = [];
        for (var i in this._layers)
            this._layers.hasOwnProperty(i) && e.push(i);
        return e.sort((function(e, i) {
            return e - i
        }
        ))
    },
    _removeLayers: function(e) {
        for (var i = 0, t = e.length; i < t; i++)
            this._map && this._map.removeLayer(this._layers[e[i]]),
            delete this._layers[e[i]]
    },
    setMinimumForwardCache: function(e) {
        e > this._timeCacheForward && (this._timeCacheForward = e)
    },
    _getNearestTime: function(e) {
        if (this._layers.hasOwnProperty(e))
            return e;
        if (0 == this._availableTimes.length)
            return e;
        for (var i = 0, t = this._availableTimes.length; i < t && !(e < this._availableTimes[i]); i++)
            ;
        return i > 0 && i--,
        e != this._availableTimes[i] && (console.log("Search layer time: " + new Date(e).toISOString()),
        console.log("Return layer time: " + new Date(this._availableTimes[i]).toISOString())),
        this._availableTimes[i]
    }
}),

L.timeDimension.layer.tileLayer.goes = function(e, i) {
    return new L.TimeDimension.Layer.TileLayer.Goes(e,i)
};

L.Control.TimeDimensionCustom = L.Control.TimeDimension.extend({
    _getDisplayDateFormat: function (e) {
      t = this._getCurrentTimeZone();
      return t === "UTC"
        ? moment(e).utc().format("DD/MM/YYYY HH:mm UTC")
        : t === "Local"
        ? moment(e).format("DD/MM/YYYY HH:mm BRT")
        : void 0;
    },
  });
